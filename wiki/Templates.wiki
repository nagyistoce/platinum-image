#summary instructions and tips for using templated classes in Platinum
#labels Phase-Implementation

This page contains tips on C++ template usage. These may be considered trivial by seasoned programmers.

===Specifying type===
Some member functions, notably `get_parameter` in the userIOmanager, require template parameters by themselves. Typically, the template parameter(s) are automatically determined by the type of the arguments. For return values, this is not allowed in C++.

Example: to specify the return type `float` for a get_parameter call:

`userIOmanagement.get_parameter<float>(1,0);`

===image_base resolution===
When using images not generated in Platinum (i.e. loaded from file, by user or in code) the template parameters of the image are not determined at compile time. For example, an algorithm doing processing on binary images would need a binary image for input. However, when aquiring an image through 'get_image(id)' the returned type will be [image_base]. The solution is to use one of the functions described below.

||Function||Return type||Pointing to||Expects input||
||`dynamic_cast<requestedClass<type, dimension>>` ||requestedClass<type, dimension>|| *original*||requestedClass<type, dimension> or related ||
||`scalar_copycast<requestedClass<type, dimension>, type, dimension >`||requestedClass<type, dimension> (must be scalar or scalar subclass)||copy||Any scalar type||
||`binary_copycast<dimension >`||image_binary<dimension >||copy||Binary, unsigned char||
||`label_copycast<dimension >`||image_label<dimension>||copy||image_integer and subclasses||

*NOTE:* all functions return `NULL` if the cast attempt fails. In most situations this has to be accounted for, or the program will crash.

===Requesting type===

`image_binary * my_binary_pointer = dynamic_cast<image_binary<3> >(datamanagement.get_image(id));`

If the loaded image did not match, the cast will fail and return 0 (`NULL`) which is how it differs from an ordinary casting operation. _Note: remember to put spaces between the ">" signs or they will be interpreted as the stream operator (`>>`) and cause trouble._

The above code also has us assuming the image is 3-dimensional. The following gets a dimension-independent pointer to the same image, which you can use an iterator on:

`image_storage * my_pointer_to_a_bunch_of_voxels = dynamic_cast<image_storage<bool> >(datamanagement.get_image(id));`

==Forcing type==
`scalar_copycast <requestedClass<type, dimension>, type, dimension >(image_base* input)` does the same basic thing as `dynamic_cast` (but unlike the latter, it's not a built-in feature of C++). The difference is that, rather than casting the same image instance into its true data type, it will *make a copy* with the pixel type changed as requested. This only works for scalar-based data types (i.e. NOT binary, complex, RGB et.c.). *Note* also, that due to limitations in C++, the same template parameters (type, dimension) have to be specified twice as shown above.

`binary_copycast<dimension>` behaves as scalar_copycast, it similarly allows casting of binary data loaded as integer types into an [image_binary]. Values > 0 will be set to true, 0 becomes false.

`label_copycast<dimension>` yields an [image_label] object the same way.

Several examples of specifying type and requesting using the casting functions can be found in the [Histo2D] source code.




